Hello from /home/ben/.vscode-oss/extensions/jaredly.reason-vscode-1.4.0/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","refmt":"","lispRefmt":"","format_width":"80","per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/ben/Downloads/MLTeamProbsF18.ml","languageId":"ocaml","version":1,"text":"(*\r\n\r\nCOS 360                  Programming Languages\r\n\r\nProf Briggs              Team ML Problems\r\n\r\nDue date: 12/15/18 @ 8 AM\r\n\r\nPlease code the following functions as specified.  At present they have\r\nstub definitions that force the types to be right but are not correct.\r\n\r\nThere are some test cases built into the code here and you should not \r\nadd any to this source file.  If you want to do additional testing, you should \r\ndo it in a file other than this one.  You should complete the definitions and submit this\r\nfile to Blackboard.\r\n\r\nThe functions you are asked to code are\r\n\r\n1. somePairWorks\r\n\r\n2. worksForAll\r\n\r\n3. isEmpty\r\n\r\n4. containsLambda\r\n\r\n5. containsMoreThanLambda\r\n\r\n6. isInfinite\r\n\r\n7. isIn\r\n\r\n8. to build to a recursive descent parser based on a given grammar, define some functions\r\n   for the grammar variables: L, X, Q, E, W, N, and B\r\n\r\n9. evaluateExpression\r\n\r\n10. based on an imperative program, code four functions to mimic its behavior: preLoop, \r\n   loopBody, loop, postLoop\r\n\r\nMore details are given below.\r\n\r\nALL THE FUNCTIONS YOU NEED TO DEFINE ARE CURRENTLY DEFINED WITH INCORRECT STUBS SO THAT\r\nTHIS FILE CAN BE PROCESSED BY ML AS IT IS. YOU WILL  NEED TO REPLACE THE STUB CODE WITH\r\nCORRECT CODE.\r\n\r\n*)\r\n\r\n(*\r\n\r\n1.\r\n\r\nWrite a curried polymorphic function, somePairWorks, that takes three arguments.\r\nThe first is a function f from 'a to boolean, the second is a function g from\r\n'b to boolean, and the third is a list of 'a * 'b pairs, like\r\n\r\n[]\r\n[(a1,b1)]\r\n[(a1,b1), (a1,b2), (a3,b3)]\r\netc.\r\n\r\nIt should return true when there is at least one pair (x,y) on the list such that\r\nboth f x and g y are true.\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\nfun somePairWorks f g L =\r\n   if null L then\r\n      true\r\n   else\r\n      let\r\n         val (x, y) = hd L\r\n      in\r\n         if f x then\r\n            false\r\n         else\r\n            if g y then\r\n               false\r\n            else\r\n               false\r\n      end;\r\n\r\n\r\n(*  a few test cases *)\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1,\"cat\"), (0, \"\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1,\"\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(~1,\"\"),(0,\"a\"), (3,\"cat\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(~1,\"\"),(0,\"a\"), (3,\"cat\"),(1,\"\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1,\"\"),(~1,\"\"),(0,\"a\"), (3,\"cat\")];\r\nsomePairWorks (fn s => s <> \"\")(fn n => n = 0) [(\"\", ~1), (\"\", 0), (\"a\", 2), (\"\", 0), (\"b\", 4), (\"art\", 6)];\r\nsomePairWorks (fn s => s <> \"\")(fn n => n = 0) [(\"\", 0),(\"\", ~1), (\"\", 0), (\"a\", 2), (\"\", 0), (\"b\", 4), (\"art\", ~1)];\r\nsomePairWorks (fn s => s <> \"\")(fn n => n = 0) [(\"\", ~1), (\"\", 0), (\"a\", 2), (\"\", 0), (\"b\", 4), (\"art\", 0), (\"\",0)];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1, \"cat\"), (~1, \"dog\"), (0, \"\"), (1, \"a\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1, \"\"), (1, \"cat\"), (~1, \"dog\"), (0, \"\"), (1, \"a\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1, \"cat\"), (~1, \"dog\"), (1, \"\"), (0, \"\"), (1, \"a\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1, \"cat\"), (~1, \"dog\"), (0, \"\"), (1, \"a\"), (1, \"\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(0,\"\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(1,\"cat\")];\r\nsomePairWorks (fn n => n > 0) (fn s => s = \"\")  [(0,\"cat\")];\r\n\r\n\r\n\r\n(*\r\n\r\n2.  Write a curried polymorphic function, worksForAll, that takes two arguments,\r\n    f, a function from 'a to boolean, and L, an 'a list.\r\n\r\n    It should return true when f x is true for EVERY value x in the list, which is\r\n    equivalent to there DOES NOT EXIST a value x on the list for which f x is false.\r\n\r\n    Consider what that implies for the empty list.\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\nfun worksForAll f nil = false |\r\n    worksForAll f (x::L) = f x;\r\n\r\n\r\n\r\n(* some test cases *)\r\n\r\nworksForAll (fn n => n > 0) [];\r\nworksForAll (fn n => n > 0) [0];\r\nworksForAll (fn n => n > 0) [1];\r\nworksForAll (fn n => n > 0) [0,~1];\r\nworksForAll (fn n => n > 0) [10,1];\r\nworksForAll (fn n => n > 0) [10,~1];\r\nworksForAll (fn n => n > 0) [0,11];\r\nworksForAll (fn n => n > 0) [1,2,3,4,5,6,7,8,9];\r\nworksForAll (fn n => n > 0) [1,2,3,4,5,6,7,8,9,0];\r\nworksForAll (fn n => n > 0) [0,1,2,3,4,5,6,7,8,9];\r\nworksForAll (fn n => n > 0) [1,2,3,4,5,0,6,7,8,9];\r\nworksForAll (fn s => s <> \"\")[];\r\nworksForAll (fn s => s <> \"\")[\"\"];\r\nworksForAll (fn s => s <> \"\")[\"1\"];\r\nworksForAll (fn s => s <> \"\")[\"\", \"~1\"];\r\nworksForAll (fn s => s <> \"\")[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\r\nworksForAll (fn s => s <> \"\")[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"\"];\r\nworksForAll (fn s => s <> \"\")[\"\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\r\nworksForAll (fn s => s <> \"\")[\"1\", \"2\", \"3\", \"4\", \"5\", \"\", \"6\", \"7\", \"8\", \"9\"];\r\n\r\n\r\n\r\n(*\r\n\r\nThe following defines a datatype for regular expressions.  Recall the\r\nrecursive definition of regular expressions over an alphabet Sigma\r\n\r\nBasis\r\n  1. the empty set is a regular expression\r\n  2. for sigma in Sigma, sigma is a regular expression\r\n\r\nInduction/Recursion: if e1 and e2 are regular expressions\r\n  1. (e1 e2), the concatenation, is a regular expression\r\n  2. (e1 + e2), the union, is a regular expression\r\n  3. (e1 * ), the iteration, is a regular expression\r\n\r\nThis ML definition follows that, using char for Sigma.\r\n\r\n*)\r\n\r\ndatatype RE = emptyset | atom of char | conc of RE * RE | union of RE * RE | star of RE;\r\n\r\n(*\r\n\r\nThe following defines a number of RE instances.\r\n\r\n*)\r\nval a = atom #\"a\";   (*  a   *)\r\nval b = atom #\"b\";   (*  b   *)\r\nval ab = conc(a,b);\r\nval space = atom #\" \";  (* ' ' *)\r\nval arbWS = star space; (*  ' '*  *)\r\nval nonEmptyWS = conc(space, arbWS);   (*  ' '+  *)\r\nval aStarBStar = conc(star a, star b);  (*  a*b*   *)\r\nval justLambda = star(emptyset);   (* contains just the empty string *) \r\nval aPlusBPlus = conc(conc(a ,star a), conc(b, star b)); (* a+b+ *)\r\nval aOrB = union(a, b); (* a|b  *)\r\nval allABPairs = conc(aOrB, aOrB);   (* (a|b)(a|b)  *)\r\nval twoEmpties = union(emptyset,emptyset);   (* still empty! (or is it half-empty?) *)\r\nval firstEmpty = union(emptyset,a);       (* a *)\r\nval secondEmpty = union(b, emptyset);      (* b *)\r\nval leftConcEmpty = conc(twoEmpties, a);   (* {} *)\r\nval rightConcEmpty = conc(b, twoEmpties);    (* {}  *)\r\nval bothConcEmpty = conc(emptyset, emptyset);  (* {} *)\r\nval inffirstEmpty = union(emptyset,aStarBStar);   (* a*b*  *)\r\nval infsecondEmpty = union(aPlusBPlus, emptyset);  (* a+b+ *)\r\nval infleftConcEmpty = conc(twoEmpties, arbWS);    (* {}  *)\r\nval infrightConcEmpty = conc(nonEmptyWS, twoEmpties);   (* {}  *)\r\nval aStar = star a;  (* a*  *)\r\nval empty1 = conc(emptyset,a);\r\nval empty2 = union(empty1,rightConcEmpty);\r\nval empty3 = union(leftConcEmpty, empty2);\r\nval ne1 = star(empty1);\r\nval ne2 = star(empty2);\r\nval ne3 = star(empty3);\r\n\r\n\r\nval Digit = union(atom #\"0\", union(atom #\"1\", union(atom #\"2\", union(atom #\"3\", \r\n    union(atom #\"4\", union(atom #\"5\", union(atom #\"6\", union(atom #\"7\", union(atom #\"8\", \r\n    atom #\"9\")))))))));\r\nval Unsigned = conc(Digit, star(Digit));\r\nval Signed = conc(union(star(emptyset),atom #\"-\"),Unsigned);\r\nval Mantissa = conc(Signed, conc(atom #\".\", Unsigned));\r\nval Exponent = conc(atom #\"e\", Signed);\r\nval hasExponent = conc(union(Mantissa,Signed),Exponent);\r\nval FloatingPoint = union(Mantissa,hasExponent);\r\n\r\n\r\n\r\n(*\r\n\r\n\r\n3. \r\n\r\nWrite a function, isEmpty, that takes a single RE argument and returns true if the\r\nset of strings it denotes is empty(which is different from it being just emptyset,\r\nwhich is what the stub below codes; you have to recursively determine whether the \r\ngiven RE denotes a nonempty set of strings) and false if it is not empty.\r\n\r\nAs an example of how pattern matching is used with the RE datatype, here is a \r\nfunction that constructs the RE that denotes the language that is the reverse of \r\nthe language denoted by the input RE\r\n\r\nfun reverseRE (union(x,y)) = union(reverseRE x, reverseRE y) |\r\n    reverseRE (conc(x,y))  = conc(reverseRE y, reverseRE x)  |\r\n    reverseRE (star x)     = star(reverseRE x) |\r\n    reverseRE e = e  (* because the reversed language of the basis cases are just\r\n                          themselves *)\r\n;\r\n\r\nIt's easy enough to determine when the basis cases are empty, but for the others,\r\nyou will need to consider how the emptiness of the subexpressions affects the\r\nemptiness of the whole expression.\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\nfun isEmpty (union(x,y)) = true |\r\n    isEmpty _            = false;\r\n\r\n(* some tests *)\r\n\r\nisEmpty a;\r\nisEmpty b;\r\nisEmpty aStarBStar;\r\nisEmpty justLambda;\r\nisEmpty aPlusBPlus;\r\nisEmpty aOrB;\r\nisEmpty allABPairs;\r\nisEmpty twoEmpties;\r\nisEmpty firstEmpty;\r\nisEmpty secondEmpty;\r\nisEmpty leftConcEmpty;   \r\nisEmpty rightConcEmpty;    \r\nisEmpty bothConcEmpty;    \r\nisEmpty space;        \r\nisEmpty arbWS;        \r\nisEmpty nonEmptyWS;        \r\nisEmpty Digit;\r\nisEmpty Unsigned;\r\nisEmpty Signed;\r\nisEmpty Mantissa;\r\nisEmpty Exponent;\r\nisEmpty hasExponent;\r\nisEmpty FloatingPoint;\r\nisEmpty inffirstEmpty;         \r\nisEmpty infsecondEmpty;         \r\nisEmpty infleftConcEmpty;         \r\nisEmpty infrightConcEmpty;\r\nisEmpty empty1;\r\nisEmpty empty2;\r\nisEmpty empty3;\r\nisEmpty ne1;\r\nisEmpty ne2;\r\nisEmpty ne3;\r\n\r\n\r\n\r\n\r\n(*\r\n\r\n\r\n4.\r\n\r\nWrite a function, containsLambda, that takes a single RE argument e and\r\nreturns true if the language that e denotes contains the empty string and\r\nfalse if it does not contain the empty string.\r\n\r\nRECALL Lambda is NOT a symbol.\r\n\r\nAgain, the basis cases are easy enough, but for each of the three non\r\nbasis cases, what are the conditions for Lambda being in them based\r\non Lambda being in the subexpressions?\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\n\r\nfun containsLambda (union(x,y)) = true |\r\n    containsLambda _ = false \r\n;\r\n\r\n(* some tests *)\r\n\r\ncontainsLambda a;\r\ncontainsLambda b;\r\ncontainsLambda aStarBStar;\r\ncontainsLambda justLambda;\r\ncontainsLambda aPlusBPlus;\r\ncontainsLambda aOrB;\r\ncontainsLambda allABPairs;\r\ncontainsLambda twoEmpties;\r\ncontainsLambda firstEmpty;\r\ncontainsLambda secondEmpty;\r\ncontainsLambda leftConcEmpty;   \r\ncontainsLambda rightConcEmpty;    \r\ncontainsLambda bothConcEmpty;    \r\ncontainsLambda space;        \r\ncontainsLambda arbWS;        \r\ncontainsLambda nonEmptyWS;        \r\ncontainsLambda Digit;\r\ncontainsLambda Unsigned;\r\ncontainsLambda Signed;\r\ncontainsLambda Mantissa;\r\ncontainsLambda Exponent;\r\ncontainsLambda hasExponent;\r\ncontainsLambda FloatingPoint;\r\ncontainsLambda inffirstEmpty;         \r\ncontainsLambda infsecondEmpty;         \r\ncontainsLambda infleftConcEmpty;         \r\ncontainsLambda infrightConcEmpty;\r\ncontainsLambda empty1;\r\ncontainsLambda empty2;\r\ncontainsLambda empty3;\r\ncontainsLambda ne1;\r\ncontainsLambda ne2;\r\ncontainsLambda ne3;\r\n\r\n\r\n\r\n(*\r\n\r\n\r\n5.\r\n\r\nWrite a function, containsMoreThanLambda, that takes a single RE argument e and\r\nreturns true if the language that e denotes contains some nonempty string s\r\nand false if it is either empty or contains only the empty string.\r\n\r\n\r\nThe basis cases are easy, but for each of the three non basis cases,\r\nwhat are equivalent conditions for the result of the regular operator\r\nto contain a nonempty string?\r\n\r\n(L * ) contains a nonempty string s iff ??\r\n(L1 + L2) contains a nonempty string s iff ??\r\n(L1 L2) contains a nonempty string s iff ??\r\n\r\nIt's a little tricky, but if you use the definitions of the regular operators, you\r\ncan replace the \"s is in E\" part with the appropriate expression for the \r\nspecific regular operator of E in the following.\r\n\r\nthere exists s (s is in E and s is not empty)\r\n\r\nand reason from there.\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\nfun containsMoreThanLambda emptyset = true |\r\n    containsMoreThanLambda _ = true;\r\n\r\n\r\n(* some tests *)\r\n\r\ncontainsMoreThanLambda a;\r\ncontainsMoreThanLambda b;\r\ncontainsMoreThanLambda aStarBStar;\r\ncontainsMoreThanLambda justLambda;\r\ncontainsMoreThanLambda aPlusBPlus;\r\ncontainsMoreThanLambda aOrB;\r\ncontainsMoreThanLambda allABPairs;\r\ncontainsMoreThanLambda twoEmpties;\r\ncontainsMoreThanLambda firstEmpty;\r\ncontainsMoreThanLambda secondEmpty;\r\ncontainsMoreThanLambda leftConcEmpty;   \r\ncontainsMoreThanLambda rightConcEmpty;    \r\ncontainsMoreThanLambda bothConcEmpty;    \r\ncontainsMoreThanLambda space;        \r\ncontainsMoreThanLambda arbWS;        \r\ncontainsMoreThanLambda nonEmptyWS;        \r\ncontainsMoreThanLambda Digit;\r\ncontainsMoreThanLambda Unsigned;\r\ncontainsMoreThanLambda Signed;\r\ncontainsMoreThanLambda Mantissa;\r\ncontainsMoreThanLambda Exponent;\r\ncontainsMoreThanLambda hasExponent;\r\ncontainsMoreThanLambda FloatingPoint;\r\ncontainsMoreThanLambda inffirstEmpty;         \r\ncontainsMoreThanLambda infsecondEmpty;         \r\ncontainsMoreThanLambda infleftConcEmpty;         \r\ncontainsMoreThanLambda infrightConcEmpty;\r\ncontainsMoreThanLambda empty1;\r\ncontainsMoreThanLambda empty2;\r\ncontainsMoreThanLambda empty3;\r\ncontainsMoreThanLambda ne1;\r\ncontainsMoreThanLambda ne2;\r\ncontainsMoreThanLambda ne3;\r\n\r\n\r\n(*\r\n\r\n\r\n6.\r\n\r\nWrite a function, isInfinite, that takes a single RE argument e and\r\nreturns true if the language that e denotes contains infinitely many strings\r\nand false if it contains only finitely many strings.\r\n\r\nSame plan goes here: deal with basis cases, and then consider the three\r\nconstructors.  You will need to check more than just isInfinite on the\r\nsubExpressions.\r\n\r\nAgain, this gets a little tricky, so you want to consider each case \r\nvery carefully and determine equivalent conditions for\r\n\r\nisInfinite L\r\n\r\ninvolving only the subexpressions of L, when L is not a basis case.\r\n\r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\n\r\nfun isInfinite (star x)  = false |\r\n    isInfinite _ = false;\r\n\r\n(* some tests *)\r\n\r\nisInfinite a;   (*  a *)\r\nisInfinite b;   (*  b *)\r\nisInfinite aStarBStar;  \r\nisInfinite justLambda;\r\nisInfinite aPlusBPlus;\r\nisInfinite aOrB;\r\nisInfinite allABPairs;\r\nisInfinite twoEmpties;\r\nisInfinite firstEmpty;\r\nisInfinite secondEmpty;\r\nisInfinite leftConcEmpty;   \r\nisInfinite rightConcEmpty;    \r\nisInfinite bothConcEmpty;    \r\nisInfinite space;        \r\nisInfinite arbWS;        \r\nisInfinite nonEmptyWS;        \r\nisInfinite Digit;\r\nisInfinite Unsigned;\r\nisInfinite Signed;\r\nisInfinite Mantissa;\r\nisInfinite Exponent;\r\nisInfinite hasExponent;\r\nisInfinite FloatingPoint;\r\nisInfinite inffirstEmpty;         \r\nisInfinite infsecondEmpty;         \r\nisInfinite infleftConcEmpty;   \r\nisInfinite infrightConcEmpty;\r\nisInfinite empty1;\r\nisInfinite empty2;\r\nisInfinite empty3;\r\nisInfinite ne1;\r\nisInfinite ne2;\r\nisInfinite ne3;\r\n\r\n\r\n(*\r\n\r\nThe next function definition is for an auxiliary function you will\r\nneed below.\r\n\r\nIt takes a string s.  If s has fewer than 2 characters,\r\nit returns the empty list, else it returns a list of all pairs\r\n(x,y)  where neither x nor y is the empty string and x ^ y = s\r\n\r\nFor example, if s were \"cat\", it would return\r\n\r\n[(\"c\",\"at\"), (\"ca\",\"t\")]\r\n\r\nIf s were \"buzz\", it would return\r\n\r\n[(\"b\",\"uzz\"), (\"bu\",\"zz\"), (\"buz\",\"z\")]\r\n\r\n*)\r\n\r\n\r\nfun allTwoSplits (s:string) =\r\n  let\r\n     val n = size s \r\n  in\r\n     if n < 2 then\r\n        []\r\n     else\r\n        let\r\n           val S = explode s\r\n           (*\r\n\r\n               fromTo lo hi = [] if lo > hi\r\n                              [ lo, (lo + 1), ..., hi ]  else\r\n\r\n           *)\r\n           val rec fromTo = fn lo => fn hi => if lo > hi then\r\n                                                 []\r\n                                              else\r\n                                                 lo :: (fromTo (lo + 1) hi)\r\n           val firstSizes = fromTo 1 (n - 1) (* [ 1, 2, ..., n-1]  *)\r\n           (*\r\n               take amt L = []  if null L or amt <= 0\r\n                            L   if amt >= length of L\r\n                            L'  where L' is the first amt items from L, else\r\n           *)\r\n           val rec take = fn amt => fn [] => [] |\r\n                                       x::L => if amt > 0 then\r\n                                                  x::(take (amt-1) L)\r\n                                               else\r\n                                                  []\r\n           val rec allBut = fn amt => fn [] => [] |\r\n                                      x::L =>  if amt > 0 then\r\n                                                  allBut (amt - 1) L\r\n                                               else\r\n                                                  x::L\r\n           val rec oneSplit = fn amt => (implode(take amt S), implode(allBut amt S))\r\n        in\r\n           map oneSplit firstSizes\r\n        end\r\n   end;\r\n\r\n(* test it a bit *)\r\nallTwoSplits \"\";\r\nallTwoSplits \"a\";\r\nallTwoSplits \"ab\";\r\nallTwoSplits \"abcdefg\";\r\n                  \r\n\r\n(*\r\n\r\n7.\r\n\r\nWrite a curried function, isIn that takes two arguments.  The first is an RE value e and the\r\nsecond is a string value s, and the function should return true when s is in the language that\r\nthe regular expression e denotes.\r\n\r\nThis fairly complicated, so I will set up the patterns, fill them in with stubs, and give you some\r\nhints on how to code them.\r\n\r\nSome recursive approaches to this one can take a long time.  Try to deal with simple cases first\r\nand avoid making a recursive call if it cannot work. \r\n\r\nYOU MUST CODE THIS.\r\n\r\n*)\r\n\r\n\r\nfun isIn emptyset (s:string) = false | (* replace with the obvious correct value *)\r\n\r\n    isIn (atom c) s   =  false | (* s needs to consist just of character c;\r\n                                      you can get the list of characters in s with\r\n                                      (explode s)\r\n                                  *)\r\n\r\n    isIn (union (e1,e2)) s =  false | (* basic logic: x is in the union of A and B iff ... *)\r\n\r\n\r\n    isIn (conc (e1,e2)) s =  false | (* split into cases where \r\n                                        s is the empty string\r\n                                        s has length 1\r\n                                        s has length > 1\r\n\r\n                                        and use the auxiliary functions containsLambda,\r\n                                        allTwoSplits and somePairWorks\r\n\r\n                                        note, if s has length 1, allTwoSplits of s will\r\n                                        be the empty list\r\n\r\n                                        this one shows the utility of a curried function,\r\n                                        since the recursive calls can use isIn with something\r\n                                        different from conc(e1,e2)\r\n\r\n                                      *)\r\n\r\n    isIn (star e) s = false; (*\r\n                                 split the cases like for the concatenation\r\n                                 s is \"\"\r\n                                 s is a single character\r\n                                 s has length > 1\r\n                                  \r\n                                 By definition, s is in e* iff s is empty, or it can be\r\n                                 broken into n nonempty parts, s1 s2 ... sn, for some n, with\r\n                                 each si in e.  An earlier solution generated ALL such breakdowns,\r\n                                 and tested each, but the combinatorics was such that the recursion\r\n                                 could take hours for a long string.  Better is to use allTwoSplits to\r\n                                 get all the breaks of s into (firstPart, secondPart) pairs, and test\r\n                                 firstPart for membership in e and secondPart from membership in e*.\r\n                                 The advantage of this is that IF firstPart is not in e, then it is not\r\n                                 necessary or desirable to generate all the breakups of secondPart,\r\n                                 so the recursion executes much more quickly.  For a length n s, there\r\n                                 are only n-1 ways to break s into two nonempty parts.\r\n\r\n                              *)\r\n                                  \r\n\r\n\r\n\r\n\r\nisIn a \"a\";\r\nisIn a \"abcd\";\r\nisIn a \"\";\r\nisIn a \"b\";\r\nisIn a \"ba\";\r\nisIn ab \"ba\";\r\nisIn ab \"ab\";\r\nisIn twoEmpties \"\";\r\nisIn firstEmpty \"\";\r\nisIn secondEmpty \"\";\r\nisIn twoEmpties \"a\";\r\nisIn firstEmpty \"a\";\r\nisIn secondEmpty \"a\";\r\nisIn twoEmpties \"b\";\r\nisIn firstEmpty \"b\";\r\nisIn secondEmpty \"b\";\r\nisIn (union(a, a)) \"a\";\r\nisIn (conc(a, a)) \"aa\";\r\nisIn (union(a, a)) \"\";\r\nisIn (conc(a, a)) \"\";\r\nisIn (conc(empty1, ne1)) \"\";   (*   *)\r\nisIn (conc(ne2, empty2)) \"\";\r\nisIn (conc(ne2, ne1)) \"\";\r\nisIn (conc(ne3, ne2)) \"\";\r\nisIn (conc(ne1, ne2)) \"\";\r\nisIn (conc(a, ne1)) \"\";\r\nisIn (conc(ne2, b)) \"\";\r\nisIn (conc(empty1, ne1)) \"a\";\r\nisIn (conc(ne2, empty2)) \"a\";\r\nisIn (conc(a, ne1)) \"a\";\r\nisIn (conc(ne3, a)) \"a\";\r\nisIn (conc(a, a)) \"a\";\r\nisIn (conc(a, ne1)) \"a\";\r\nisIn (conc(ne2, b)) \"a\";\r\nisIn (conc(b, ne2)) \"a\";\r\nisIn (conc(empty1, ne1)) \"ab\";\r\nisIn (conc(ne2, empty2)) \"ab\";\r\nisIn (conc(ab, ne1)) \"ab\";\r\nisIn (conc(ne3, ab)) \"ab\";\r\nisIn (conc(a, b)) \"ab\";\r\nisIn (conc(ab, ne1)) \"ab\";\r\nisIn (conc(ne2, conc(b,a))) \"ab\";\r\nisIn (conc(b, a)) \"ab\";\r\n\r\nisIn (conc(arbWS,conc(a,conc(arbWS,conc(b,arbWS))))) \" a b \";\r\nisIn (conc(arbWS,conc(a,conc(arbWS,conc(b,arbWS))))) \"ab\";\r\nisIn (conc(arbWS,conc(a,conc(arbWS,conc(b,arbWS))))) \"ba\";\r\nisIn (conc(justLambda,allABPairs)) \"aa\";\r\nisIn (conc(justLambda,allABPairs)) \"ab\";\r\nisIn (conc(justLambda,allABPairs)) \"ba\";\r\nisIn (conc(justLambda,allABPairs)) \"bb\";\r\nisIn (conc(allABPairs,justLambda)) \"aa\";\r\nisIn (conc(allABPairs,justLambda)) \"ab\";\r\nisIn (conc(allABPairs,justLambda)) \"ba\";\r\nisIn (conc(allABPairs,justLambda)) \"bb\";\r\nisIn arbWS \"\";\r\nisIn arbWS \" \";\r\nisIn arbWS \"a\";\r\nisIn arbWS \"ab\";\r\nisIn arbWS \" a\";\r\nisIn arbWS \" a \";\r\nisIn arbWS \"       \";\r\nisIn nonEmptyWS \"\";\r\nisIn nonEmptyWS \" \";\r\nisIn nonEmptyWS \"     \";\r\nisIn aStarBStar \"\";\r\nisIn aStarBStar \"b\";\r\nisIn aStarBStar \"bbb\";\r\nisIn aStarBStar \"a\";\r\nisIn aStarBStar \"aaa\";\r\nisIn aStarBStar \"bba\";\r\nisIn aStarBStar \"aaabbb\";\r\nisIn justLambda \"\";\r\nisIn justLambda \"b\";\r\nisIn justLambda \"a\";\r\nisIn allABPairs \"b\";\r\nisIn allABPairs \"ab\";\r\nisIn allABPairs \"ba\";\r\nisIn allABPairs \"aa\";\r\nisIn allABPairs \"bb\";\r\nisIn allABPairs \"a\";\r\nisIn allABPairs \"aba\";\r\nisIn emptyset \"\";\r\nisIn emptyset \"a\";\r\nisIn emptyset \"ab\";\r\n\r\nisIn empty1 \"\";\r\nisIn empty2 \"\";\r\nisIn empty3 \"\";\r\nisIn ne1 \"\";\r\nisIn ne1 \"a\";\r\nisIn ne2 \"a\";\r\nisIn ne3 \"a\";\r\nisIn ne1 \"aa\";\r\n\r\nval ShowABreak = \"*****************************************\";\r\n\r\nisIn a \"aaaaaaaaaab\";      \r\nisIn b \"aaaaaaaaaab\";      \r\nisIn space \"aaaaaaaaaab\";      \r\nisIn arbWS \"aaaaaaaaaab\";      \r\nisIn nonEmptyWS \"aaaaaaaaaab\";      \r\nisIn aStarBStar \"aaaaaaaaaab\";      \r\nisIn justLambda \"aaaaaaaaaab\";      \r\nisIn aPlusBPlus \"aaaaaaaaaab\";      \r\nisIn aOrB \"aaaaaaaaaab\";      \r\nisIn allABPairs \"aaaaaaaaaab\";      \r\nisIn twoEmpties \"aaaaaaaaaab\";      \r\nisIn firstEmpty \"aaaaaaaaaab\";      \r\nisIn secondEmpty \"aaaaaaaaaab\";      \r\nisIn leftConcEmpty \"aaaaaaaaaab\";      \r\nisIn rightConcEmpty \"aaaaaaaaaab\";      \r\nisIn bothConcEmpty \"aaaaaaaaaab\";      \r\nisIn inffirstEmpty \"aaaaaaaaaab\";      \r\nisIn infsecondEmpty \"aaaaaaaaaab\";      \r\nisIn infleftConcEmpty \"aaaaaaaaaab\";      \r\nisIn infrightConcEmpty \"aaaaaaaaaab\";      \r\nisIn aStar \"aaaaaaaaaab\";      \r\n\r\n\r\nval test2 = [\r\n         \"-123\",\r\n         \"1.2\",\r\n         \"0.0\",\r\n         \"-0.0\",\r\n         \"1.-00\",\r\n         \"-1.-00\",\r\n         \"1.9\",\r\n         \"2.8\",\r\n         \"3.7\",\r\n         \"4.6\",\r\n\r\n         \"5.5\",\r\n         \"6.4\",\r\n         \"7.3\",\r\n         \"8.2\",\r\n         \"9.1\",\r\n         \"-1.9\",\r\n         \"-2.8\",\r\n         \"-3.7\",\r\n         \"-4.6\",\r\n         \"-5.5\",\r\n\r\n         \"-6.4\",\r\n         \"-7.3\",\r\n         \"-8.2\",\r\n         \"-9.1\",\r\n         \"1e0\",\r\n         \"2e1\",\r\n         \"3e2\",\r\n         \"4e3\",\r\n         \"5e4\",\r\n         \"6e5\",\r\n\r\n         \"7e6\",\r\n         \"8e7\",\r\n         \"9e8\",\r\n         \"0e9\",\r\n         \"-1e0\",\r\n         \"-2e1\",\r\n         \"-3e2\",\r\n         \"-4e3\",\r\n         \"-5e4\",\r\n         \"-6e5\",\r\n\r\n         \"-7e6\",\r\n         \"-8e7\",\r\n         \"-9e8\",\r\n         \"-0e9\",\r\n         \"-1e-0\",\r\n         \"-2e-1\",\r\n         \"-3e-2\",\r\n         \"-4e-3\",\r\n         \"-5e-4\",\r\n         \"-6e-5\",\r\n\r\n         \"-7e-6\",\r\n         \"-8e-7\",\r\n         \"-9e-8\",\r\n         \"-0e-9\",\r\n         \"1e-0\",\r\n         \"2e-1\",\r\n         \"3e-2\",\r\n         \"4e-3\",\r\n         \"5e-4\",\r\n         \"6e-5\",\r\n\r\n         \"7e-6\",\r\n         \"8e-7\",\r\n         \"9e-8\",\r\n         \"0e-9\",\r\n         \"1.9e01\",\r\n         \"2.8e02\",\r\n         \"3.7e03\",\r\n         \"4.6e04\",\r\n         \"5.5e05\",\r\n         \"6.4e06\",\r\n\r\n         \"7.3e07\",\r\n         \"8.2e08\",\r\n         \"9.1e09\",\r\n         \"-1.9e01\",\r\n         \"-2.8e02\",\r\n         \"-3.7e03\",\r\n         \"-4.6e04\",\r\n         \"-5.5e05\",\r\n         \"-6.4e06\",\r\n         \"-7.3e07\",\r\n\r\n         \"-8.2e08\",\r\n         \"-9.1e09\",\r\n         \"1.9e-01\",\r\n         \"2.8e-02\",\r\n         \"3.7e-03\",\r\n         \"4.6e-04\",\r\n         \"5.5e-05\",\r\n         \"6.4e-06\",\r\n         \"7.3e-07\",\r\n         \"8.2e-08\",\r\n\r\n         \"9.1e-09\",\r\n         \"-1.9e-01\",\r\n         \"-2.8e-02\",\r\n         \"-3.7e-03\",\r\n         \"-4.6e-04\",\r\n         \"-5.5e-05\",\r\n         \"-6.4e-06\",\r\n         \"-7.3e-07\",\r\n         \"-8.2e-08\",\r\n         \"-9.1e-09\",\r\n\r\n         \" 1.9e01\",\r\n         \" 2.8e02\",\r\n         \" 3.7e03\",\r\n         \" 4.6e04\",\r\n         \" 5.5e05\",\r\n         \" 6.4e06\",\r\n         \"\\n7.3e07\",\r\n         \" +8.2e08\",\r\n         \" +9.1e09\",\r\n         \"-1.9e01 \",\r\n\r\n         \"-2.8e02 \",\r\n         \"-3.7e03 \",\r\n         \"-4.6e04 \",\r\n         \"-5.5e05 \",\r\n         \"-6.4e06 \",\r\n         \"-7.3e07 \",\r\n         \"-8.2e08 \",\r\n         \"-9.1e09 \",\r\n         \"1.9 e-01\",\r\n         \"2.8 e-02\",\r\n\r\n         \"3.7 e-03\",\r\n         \"4.6 e-04\",\r\n         \"5.5 e-05\",\r\n         \"6.4 e-06\",\r\n         \"7.3e -07\",\r\n         \"8.2e -08\",\r\n         \"9.1e -09\",\r\n         \"-1.9e -01\",\r\n         \"-2.8e -02\",\r\n         \"-3.7e -03\",\r\n\r\n         \"-4.6e -04\",\r\n         \"-5.5e -05\",\r\n         \"-6.4e -06\",\r\n         \"-7.3e -07\",\r\n         \"-8.2e -08\",\r\n         \"-9.1e -09\",\r\n         \"0.0\",\r\n         \"-0.89\",\r\n         \"12e-200\",\r\n         \"-0 .314159e1\",\r\n\r\n         \"1e00\",\r\n         \"-1. 2\",\r\n         \"10e--12\",\r\n         \"12\",\r\n         \"-0 1 2 3 4 5 6 7 8 . 9\",\r\n         \"123.\",\r\n         \"7e\",\r\n         \".2\",\r\n         \"1.\",\r\n         \"-.3\",\r\n\r\n         \" 1.2\",\r\n         \" -0.89\",\r\n         \" 12e-200\",\r\n         \" -0.314159e1\",\r\n         \" 1e00\",\r\n         \" --1.2\",\r\n         \" 10e--12\",\r\n         \" 12\",\r\n         \"-89\",\r\n         \" 7e\",\r\n\r\n         \" .2\",\r\n         \" -.3\",\r\n         \"1.2 \",\r\n         \"-0.89 \",\r\n         \"12e-200 \",\r\n         \"-0.314159e1 \",\r\n         \"1e00 \",\r\n         \"--1.2 \",\r\n         \"10e--12 \",\r\n         \"12 \",\r\n\r\n         \"-89 \",\r\n         \"7e \",\r\n         \".2 \",\r\n         \"-.3 \",\r\n         \"1.2 \",\r\n         \"-0.89 \",\r\n         \"12e-200 \",\r\n         \"-0.314159e1 \",\r\n         \"1e00 \",\r\n         \"--1.2 \",\r\n\r\n         \"10e--12 \",\r\n         \"12 \",\r\n         \"-89 \",\r\n         \"7e \",\r\n         \".2 \",\r\n         \"-.3 \",\r\n         \"   +  \"\r\n];\r\n\r\n(*\r\n\r\nthese should be right, but if you see any discrepancies, tell me\r\n\r\n*)\r\nval test2CorrectResults = [\r\nfalse,\r\ntrue,\r\ntrue,\r\ntrue,\r\nfalse,\r\nfalse,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\ntrue,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\ntrue,\r\ntrue,\r\ntrue,\r\nfalse,\r\ntrue,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse,\r\nfalse\r\n];\r\n\r\nlength test2;\r\nlength test2CorrectResults;\r\n\r\n\r\nfun identifyErrorIndices (n:int) L1 L2 =\r\n   if null L1 orelse null L2 then\r\n      []\r\n   else\r\n      let\r\n        val amatch = hd L1 = hd L2\r\n        val res = identifyErrorIndices (n+1) (tl L1) (tl L2)\r\n      in\r\n         if amatch then\r\n            res\r\n         else\r\n            n::res\r\n      end\r\n;\r\n\r\nidentifyErrorIndices 1 (map (isIn FloatingPoint) test2) test2CorrectResults;\r\n\r\n\r\n(*\r\n\r\n\r\n9. \r\n\r\nThis is an exercise in writing a simple recursive descent parser.\r\n\r\nThe following is a grammar for lists of binary numerals in which such lists can be nested, as in\r\n(note the spaces after the commas, commas must be followed by a space)\r\n\r\n(101, (), (00, 1, 10, 011), 110, 111, ((((1001)))))\r\n\r\nWe are adding a final $ to stand for the end of file/end of token sequence.  The start symbol is S.\r\nThe terminal alphabet is\r\n\r\n(  )  0  1  ,  $  ' '\r\n\r\nwhere the last pair of single quotes stand for the space character.  Note that each terminal is a\r\nsingle character, so we will not need a scanner to tokenize a string.\r\n\r\nThe variable set is\r\n\r\nS  the start symbol\r\nN  for binary numeral\r\nB  for bit sequence\r\nL  for list\r\nE   for list item, which might be a binary numeral, or another list\r\nX  for list suffix\r\nQ for a non empty sequence of items separated by , ' '\r\nW for the suffix of a non empty sequence(this is needed to deal with a single item list sequence, as in\r\n    (1001)  versus a multi item list sequencce, as in (1, 10, 11))\r\n\r\nThe productions with their lookahead sets are given below.  The lookahead sets for each rhs are just\r\nlisted but if a variable has more than one rhs, the lists are separated by vertical bars(|).  Within the\r\nlist of terminals for the lookahead set, an unquoted space is used as a separator.  A quoted space\r\nis part of the grammar and refers to the single space character that is one of the terminals.\r\nOther ws in the productions is not significant.  A pair of double quotes, \"\", is used to refer to the empty\r\nstring.\r\n\r\n\r\nS ::= L $\r\n(\r\n\r\nL ::= ( X\r\n(\r\n\r\nX ::= ) | Q\r\n)  |  (  0 1\r\n\r\nQ ::= E W\r\n( 0 1\r\n\r\nE ::= L | N\r\n(  |  0 1\r\n\r\nW ::= )  | , ' ' Q\r\n) | ,\r\n\r\nN ::= 0 |  1 B\r\n0 | 1\r\n\r\nB ::=  \"\" | 1 B | 0 B\r\n, ) | 1 | 0\r\n\r\n\r\nYour task is to write a recursive descent parser for this grammar that takes an input string\r\nand returns true if the string parses and false if it does not.  \r\n\r\nI will do some of the pieces for you, but you will code most of the innards.\r\n\r\n\r\nIf we construct a directed graph whose nodes are grammar variables, with an edge from x to y iff\r\nthere is an occurrence of y on some rhs for x, then it is\r\n\r\n                   +-----+\r\n                   |     |\r\n                   V     |\r\nS --> L  --> X --> Q --> W\r\n      A            |           +---+\r\n      |            |           |   |\r\n      |            V           V   |\r\n      +----------- E --> N --> B --+\r\n\r\nIf variable x has variable y on a rhs, this means the method for x will need\r\nto call the method for y, and a cycle identifies a sequence of calls that is \r\nultimately recursive.\r\n\r\nIf we group nodes in the same strongly connected component and perform the\r\nkind of collapse we referred to in the First and Follow set calculations, we\r\nobtain                           \r\n                                       \r\nS --> { L, X, Q, W, E } --> N --> B\r\n\r\nand we see that the only functions that need to use the\r\nmutually recursive\r\n\r\nfun ...\r\nand\r\n...\r\nand\r\n...\r\n;\r\n\r\nconstruct are L, X, Q, W, and E.\r\n\r\nThe definitions below are arranged so that if the functions are defined in that\r\norder, each will have the ones it needs.\r\n\r\nIt's really not hard at all to do this, as the grammar itself provides the \r\nblueprint.\r\n\r\nThe heart of the work is to code, for each grammar variable Y and each terminal a,\r\na function that takes a list of characters as input and either returns a list of characters\r\nthat is a suffix of the input list after the longest prefix of the input list that\r\nmatches a string in the language generated by the symbol has been consumed, or \r\nthrows the parserFailure exception defined below.\r\n\r\nThe functions will attempt to match a prefix of the input list with a string in the\r\nlanguage the symbol of the function generates.\r\n\r\nFor a terminal x, this is quite simple\r\n\r\nfun x cList = if cList has first value the same character as x then\r\n                 tl cList\r\n              else\r\n                 throw the exception\r\n\r\nIt's a little more complicated for grammar variables, but if you follow the grammar,\r\nthe coding is algorithmic.\r\n\r\nSuppose you have grammar variable variable Y with productions\r\n\r\nY ::= rhs1 | rhs2 | ... | rhsn\r\n\r\nwhere rhsM has lookahead set TM and symbols Z1 Z2 ... Zk\r\n\r\nThe function for Y proceeds\r\n\r\nY cList = \r\n\r\nif null cList then\r\n   raise parserFailure\r\nelse\r\n   let\r\n      val lookahead = hd cList\r\n   in\r\n      if lookahead is one of the values in T1 then\r\n         call function for rhs1 on cList\r\n      else if lookahead is one of the ones in T2 then\r\n         call function for rhs2 on cList\r\n      ...\r\n      else if lookahead is one of the ones in Tn\r\n         call function for rhsn on cList\r\n      else (* the lookahead is not right for any of the rhs's *)\r\n         raise parserFailure\r\n   end\r\n\r\nWhat is the function for rhsM?  Suppose rhsM is \r\n\r\nZ1 Z2 ... Zk\r\n\r\nIn an imperative language we would do calls\r\n\r\nZ1();\r\nZ2();\r\n...\r\nZk();\r\n\r\nwhere Zj() is the function for variable Zj, if Zj is a variable,\r\nor just match operation for Zj, if Zj is a terminal.  To achieve\r\nthat ordering in a functional language, however, we need to\r\nCOMPOSE the functions in reverse order and apply them\r\nto the input cList\r\n\r\n(Zk o ... o Z2 o Z1) cList\r\n\r\nwhich amounts to the expression\r\n\r\nZk( ... (Z2 (Z1 cList))..)\r\n\r\nIf all return w/o raising the exception, then they will consume the \r\nappropriate prefix of cList and return what is left.  Since none of them\r\nhandle the exception, if one raises the exception, it will propagate\r\nthrough the others.\r\n\r\nWhen Zi is a variable, then the function is just the one being defined\r\nin this collection of definitions.  When Zi is a terminal, then the \r\nfunction for Zi is\r\n\r\n(matcherGenerator Zi)\r\n\r\nwhere matcherGenerator is a function I define for you below.\r\n\r\nNote, if the Java character literal is 'c', then the ML analog is #\"c\".\r\n\r\nNow, you may ask yourself, \"Variable B generates the empty string, and\r\nthe empty string is a prefix of any string, so shouldn't the function for\r\nB always just return cList itself?\".  A fair question.\r\n\r\nFirst, we do want the longest prefix that matches, so although the empty string\r\ndoes match, we should try to match with the nonempty alternatives if we can.  \r\nSecond, although the empty string is always a prefix that matches, in the context\r\nof the parse, if the lookahead is not in the lookahead set for the \"\" rhs of B,\r\nthen the parse matching the empty string will ultimately fail, and we prefer to \r\ndetect that sooner rather than later. So you should always test that \r\nthe lookahead character is in the lookahead set for the rhs for each case.  \r\n\r\nNote if the rhs is the empty string, \"\", then the function for that rhs\r\ndoes not consume ANY of the characters of cList.\r\n\r\nWith this approach, you read the function definitions directly off the\r\ngrammar.  \r\n\r\nNote that #' ' is the ML literal for the space character.\r\n\r\n\r\nFor matching the terminals, I provide a matcher generator function the returns\r\nthe function you need.  I code the function for S below as a model for you\r\nand in it you will see how the matcher generator is used.\r\n\r\n*)\r\n\r\n        \r\n\r\n(* define an exception for failing to parse  *)\r\n\r\nexception parserFailure;\r\n\r\n(* \r\n   defines a matcher generator; it takes a single character c, and \r\n   returns a function that takes a list of characters, and if the\r\n   list begins with the input c, returns the rest of the list, else \r\n   throws the parserFailure exception\r\n*)\r\n\r\nfun matcherGenerator (c:char) =\r\n   fn []   => raise parserFailure |\r\n      x::L => if x = c then\r\n                 L\r\n              else\r\n                 raise parserFailure\r\n;\r\n\r\n(*\r\n\r\n   define a collection of functions, one for\r\n   each variable of the grammar.  Each function takes a list of\r\n   characters as input.  If a prefix of the list of characters\r\n   matches a string that the variable would generate, it returns\r\n   the list with the longest such prefix removed.  For example,  N derives\r\n\r\n   1001\r\n\r\n   so if the function for N were given\r\n\r\n   [ #\"1\", #\"0\", #\"0\", #\"1\", #\"a\", #\"b\", #\"c\", #\"d\" ]\r\n\r\n   is should return\r\n\r\n   [  #\"a\", #\"b\", #\"c\", #\"d\" ]\r\n\r\n   Although N also derives 10, it should not return\r\n\r\n   [ #\"0\", #\"1\", #\"a\", #\"b\", #\"c\", #\"d\" ]\r\n\r\n   because 10 is not the longest prefix that is in the language that N\r\n   generates.\r\n\r\n\r\n   On the other hand, if no prefix of the list generates\r\n   a string that would be in the language the variable\r\n   generates, the function should raise parserFailure.\r\n\r\n\r\n   THIS IS THE PART THAT YOU MUST CODE TO ACCOMPLISH #9.\r\n\r\n\r\n*)\r\n\r\n(*\r\n\r\nB ::=  \"\" | 1 B | 0 B\r\n, ) | 1 | 0\r\n\r\n*)\r\nfun B cList = if null cList then\r\n                 [ #\"a\" ]\r\n               \r\n              else \r\n                 cList;\r\n\r\nfun N cList = if null cList then\r\n                 [#\"a\"]\r\n              else \r\n                 cList;\r\n\r\n\r\n\r\nfun\r\n   L cList = B cList\r\nand\r\n   X cList = B cList\r\nand\r\n   Q cList = B cList\r\nand\r\n   E cList = B cList\r\nand\r\n   W cList = B cList\r\n;\r\n\r\n\r\n(*\r\n\r\nRecall,\r\n\r\nS ::= L $;\r\n\r\n(\r\n\r\nis the replacement rule with the lookahead set\r\n\r\n*)\r\n\r\nfun S cList = if null cList then\r\n                 raise parserFailure\r\n              else \r\n                if hd cList = #\"(\" then\r\n                   ((matcherGenerator #\"$\") o L ) cList\r\n                else\r\n                   raise parserFailure;\r\n\r\n\r\n(*\r\n\r\nThis final definition will then complete the task once the grammar\r\nvariable functions are defined.\r\n\r\n*)\r\n\r\n\r\nfun parse s =\r\n(*\r\n\r\nattempts to parse s by calling the start symbol on the list of\r\ncharacters in s.  If the call returns [], s parsed.  If it returns a nonempty\r\nlist, or throws and exception, s failed to parse.\r\n\r\n*)\r\n   null (S (explode s)) handle parserFailure  => false;\r\n\r\n\r\n(*\r\n\r\nyou can test it on the following\r\n\r\n\r\n  should fail for these\r\n\r\n*)\r\n\r\nval e1 = \"\";\r\nval e2 = \"$\";\r\nval e3 = \"1\";\r\nval e4 = \"0\";\r\nval e5 = \"2\";\r\nval e6 = \",\";\r\nval e7 = \"(\";\r\nval e8 = \")\";\r\nval e9 = \" \";\r\nval e10 = \"a\";\r\nval e11 = \"()\";\r\nval e12 = \"(1)\";\r\nval e13 = \"(0, 1)\";\r\nval e14 = \"((), \";\r\nval e15 = \"((), 0\";\r\nval e16 = \"((), 1\";\r\nval e17 = \"(0, \";\r\nval e18 = \"(0, 0\";\r\nval e19 = \"(0, 1\";\r\nval e20 = \"(1, \";\r\nval e21 = \"(1, 0\";\r\nval e22 = \"(1, 1\";\r\nval e23 = \"(00)$\";\r\nval e24 = \"(0,1)$\";\r\nval e25 = \"()$ \";\r\nval e26 = \"((),())$\";\r\nval e27 = \"((),0)$\";\r\nval e28 = \"((),1)$\";\r\nval e29 = \"(0,())$\";\r\nval e30 = \"(0,0)$\";\r\nval e31 = \"(0,1)$\";\r\nval e32 = \"(1,())$\";\r\nval e33 = \"(1,0)$\";\r\nval e34 = \"(((1)),1)$\";\r\nval e35 = \"((1),(0))$\";\r\nval e36 = \"((),(1))$\";\r\nval e37 = \"((0),())$\";\r\nval e38 = \"((),())$\";\r\nval e39 = \"(1,())$\";\r\nval e40 = \"((),(1))$\";\r\nval e41 = \"($)$\";\r\nval e42 = \"(,)$\";\r\nval e43 = \"(0($\";\r\nval e44 = \"( )$\";\r\nval e45 = \"(1 11 111)$\";\r\nval e46 = \"(1 11 111 )$\";\r\nval e47 = \"(1, 10, 11, )$\";\r\nval e48 = \"(1, 10, 11,)$\";\r\nval e49 = \"((((())))$\";\r\nval e50 = \"(((((((()))))))))$\";\r\n\r\nval errTests = [\r\ne1,\r\ne2,\r\ne3,\r\ne4,\r\ne5,\r\ne6,\r\ne7,\r\ne8,\r\ne9,\r\ne10,\r\ne11,\r\ne12,\r\ne13,\r\ne14,\r\ne15,\r\ne16,\r\ne17,\r\ne18,\r\ne19,\r\ne20,\r\ne21,\r\ne22,\r\ne23,\r\ne24,\r\ne25,\r\ne26,\r\ne27,\r\ne28,\r\ne29,\r\ne30,\r\ne31,\r\ne32,\r\ne33,\r\ne34,\r\ne35,\r\ne36,\r\ne37,\r\ne38,\r\ne39,\r\ne40,\r\ne41,\r\ne42,\r\ne43,\r\ne44, \r\ne45,\r\ne46,\r\ne47,\r\ne48,\r\ne49,\r\ne50\r\n];\r\n\r\n(*\r\n\r\nthis expression will produce a list of the numbers of tests components of the error test\r\nvector the parser made a mistake on; of course, you want it to return the empty list;\r\n\r\n*)\r\n\r\nlet\r\n   val resultList = map parse errTests \r\n   val  rec indicesOfTrue  = fn (n:int) =>\r\n        (fn          [] => [] |\r\n            (true::L) => n :: (indicesOfTrue (n + 1) L) |\r\n            (false::L) => indicesOfTrue (n+1) L\r\n        )\r\nin\r\n   indicesOfTrue 1 resultList\r\nend;\r\n  \r\n(*\r\n\r\nthe following should parse\r\n\r\n*)\r\nval s1 = \"()$\";\r\nval s2 = \"(0)$\";\r\nval s3 = \"(1)$\";\r\nval s4 = \"(11011010)$\";\r\nval s5 = \"(11)$\";\r\nval s6 = \"(10)$\";\r\nval s7 = \"(0, 1)$\";\r\nval s8 = \"(1, 0)$\";\r\nval s9 = \"(0, 1, 10, 11, 100, 101, 110, 111, 1000)$\";\r\nval s10 = \"(1, 1, 1)$\";\r\nval s11 = \"((), ())$\";\r\nval s12 = \"((), 0)$\";\r\nval s13 = \"(1, ())$\";\r\nval s14 = \"((1), (()))$\";\r\nval s15 = \"((11), (0))$\";\r\nval s16 = \"(((1010)), 1)$\";\r\nval s17 = \"(((1010)), ((0)))$\";\r\nval s18 = \"(1001, ((0)))$\";\r\nval s19 = \"(1, 11, 111)$\";\r\nval s20 = \"(1, 11, (1100))$\";\r\nval s21 = \"(1, 11, ((111)))$\";\r\nval s22 = \"(1, (11), 111)$\";\r\nval s23 = \"(1, (11), (111))$\";\r\nval s24 = \"(1, (11), ((111)))$\";\r\nval s25 = \"(1, ((11)), 111)$\";\r\nval s26 = \"(1, ((11)), (111))$\";\r\nval s27 = \"(1, ((11)), ((111)))$\";\r\nval s28 = \"((1), 11, 111)$\";\r\nval s29 = \"((1), 11, (1100))$\";\r\nval s30 = \"((1), 11, ((111)))$\";\r\nval s31 = \"((1), (11), 111)$\";\r\nval s32 = \"((1), (11), (111))$\";\r\nval s33 = \"((1), (11), ((111)))$\";\r\nval s34 = \"((1), ((11)), 111)$\";\r\nval s35 = \"((1), ((11)), (111))$\";\r\nval s36 = \"((1), ((11)), ((111)))$\";\r\nval s37 = \"(((1)), 11, 111)$\";\r\nval s38 = \"(((1)), 11, (1100))$\";\r\nval s39 = \"(((1)), 11, ((111)))$\";\r\nval s40 = \"(((1)), (11), 111)$\";\r\nval s41 = \"(((1)), (11), (111))$\";\r\nval s42 = \"(((1)), (11), ((111)))$\";\r\nval s43 = \"(((1)), ((11)), 111)$\";\r\nval s44 = \"(((1)), ((11)), (111))$\";\r\nval s45 = \"(((1)), ((11)), ((111)))$\";\r\nval s46 = \"((), (0), (1, 10), (0, (), 1), 11, (((((100))))))$\";\r\nval s47 = \"((1, ()), (((10)), 0), (((1, 10))), ((((0, (), 1)))), 11, (((((100))))))$\";\r\nval s48 = \"((((0))), ((1, (10, 11, 100)), ((1, 10, 110), 111), (1, (10, 110), 111), ((1, 10, 110, 111)), ((1, 10), (110, 111))))$\";\r\n(*                           12   3                 32 45               5       4  6   7           7        6 89                        98 0a      a  b             b01 *)\r\nval s49 = \"((((0))), ((1, (10, 11, 100)), ((1, 10, 110), 111), (1, (10, 110), 111), ((1, 10, 110, 111))), ((1, 10), (110, 111)))$\";\r\nval s50 = \"((((0))), (1, (10, 11, 100)), (((1, 10, 110), 111), (1, (10, 110), 111), ((1, 10, 110, 111))), ((1, 10), (110, 111)))$\";\r\n\r\nval correctTests = [\r\ns1,\r\ns2,\r\ns3,\r\ns4,\r\ns5,\r\ns6,\r\ns7,\r\ns8,\r\ns9,\r\ns10,\r\ns11,\r\ns12,\r\ns13,\r\ns14,\r\ns15,\r\ns16,\r\ns17,\r\ns18,\r\ns19,\r\ns20,\r\ns21,\r\ns22,\r\ns23,\r\ns24,\r\ns25,\r\ns26,\r\ns27,\r\ns28,\r\ns29,\r\ns30,\r\ns31,\r\ns32,\r\ns33,\r\ns34,\r\ns35,\r\ns36,\r\ns37,\r\ns38,\r\ns39,\r\ns40,\r\ns41,\r\ns42,\r\ns43,\r\ns44, \r\ns45,\r\ns46,\r\ns47,\r\ns48,\r\ns49,\r\ns50\r\n];\r\n\r\n(*\r\n\r\nthis expression will produce a list of the numbers of tests components of the correct test\r\nvector the parser made a mistake on; of course, you want it to return the empty list;\r\n\r\n*)\r\n\r\nlet\r\n   val resultList = map parse correctTests \r\n   val  rec indicesOfTrue  = fn (n:int) =>\r\n        (fn          [] => [] |\r\n            (false::L) => n :: (indicesOfTrue (n + 1) L) |\r\n            (true::L) => indicesOfTrue (n+1) L\r\n        )\r\nin\r\n   indicesOfTrue 1 resultList\r\nend;\r\n  \r\n(*\r\n\r\nThe following definitions are to accommodate integer expressions involving\r\nconstants, variables, +, -, *, div, and mod\r\n\r\nFirst, an enumeration type for the five binary operators\r\n\r\n*)\r\ndatatype BinaryOps = ADD | SUBTRACT | MULT | DIV | MOD;\r\n\r\n(*\r\n\r\nNext, the type proper.  Because we only have a single unary operator, \r\nnegation(~), the Negation tag itself is enough to tell us what operation to use.\r\n\r\n*)\r\n\r\ndatatype Expression = Variable of string | Constant of int |\r\n                      BinaryExp of BinaryOps * Expression * Expression |\r\n                      Negation of Expression;\r\n\r\n(* define a couple of exceptions *)\r\nexception UndefinedVariable of string;\r\nexception DivisionByZero;\r\n\r\n(*\r\n\r\n9.\r\n\r\nDefine a curried function\r\n\r\nevaluateExpression\r\n\r\nwith signature\r\n\r\n(string * int) list -> Expression -> int\r\n\r\nwhose first parameter is a list of (s, v) pairs that should be interpreted\r\nas values v of a variable s.  In a lookup of the value of s, use the v of the\r\nfirst pair on the list that has s as its first member.\r\n\r\nThe function should recurse on the structure of the Expression input and \r\nraise the exception DivisionByZero if the second input to a DIV or MOD expression\r\nevaluates to 0, and raise the (UndefinedVariable s) expression if during the\r\ncourse of evaluation it looks up the value of variable s and does not find\r\na pair in the (string * int) list with first member s.\r\n\r\nI'll put in a stub with the patterns below.\r\n\r\n*)\r\n\r\n(*\r\n\r\n   I'll code the look up operation put in some code to test the\r\n   companion function, evaluate expression.  This will return the integer second\r\n   component of the first pair in the list that matches the string at the first component,\r\n   or raise the exception if it does not find a pair whose first component matches the string.\r\n\r\n*)\r\nfun lookup nil (s:string) = raise UndefinedVariable(s) |\r\n    lookup ((name, value) :: L) s = if name = s then\r\n                                     value + 0 (* to force that it be int *)\r\n                                  else\r\n                                     lookup L s\r\n;\r\n\r\n(*\r\n\r\nThis is just stub code that you need to fix.\r\n\r\nNote, in my solution code, whenever the binary operator was DIV or MOD, I used let-in-end\r\nto first evaluate the right subexpression to see if it were 0.  If it were, I raised\r\nthe exception w/o evaluating the left.  If you evaluate the left first, you might\r\nthrow some other exception from mine, which would make your results different from\r\nmine. \r\n\r\n*)\r\n\r\n\r\nfun evaluateExpression _ (Constant n) = 0 |\r\n    evaluateExpression L  _           = if null L then\r\n                                          1\r\n                                       else\r\n                                          let\r\n                                            val (x,v) = hd L\r\n                                          in\r\n                                             if x = \"cat\" then\r\n                                                2\r\n                                             else \r\n                                                3 + v\r\n                                          end;\r\n                       \r\n(*\r\n\r\na function to call evaluateExpression and handle any exceptions.\r\nTo have the codomain be a single type, it converts the int values to string.\r\n\r\n*)\r\n\r\nfun runEvaluateExpression L E =\r\n   let\r\n      val s = Int.toString (evaluateExpression L E) handle\r\n                 UndefinedVariable t => \"Eval Error: the variable \" ^ t ^ \" is undefined.\" |\r\n                 DivisionByZero => \"Eval Error: division by zero.\"\r\n   in\r\n      s\r\n   end;\r\n\r\n\r\nval e9 = Variable \"n1\";\r\nval e10 = Variable \"n2\";\r\nval e11 = Variable \"n3\";\r\nval e12 = Variable \"n4\";\r\nval e13 = Variable \"n5\";\r\nval e14 = Variable \"n6\";\r\nval e15 = Variable \"n7\";\r\nval e16 = Variable \"n8\";\r\nval e17 = Variable \"n9\";\r\nval e18 = Variable \"n10\";\r\nval e19 = Variable \"n11\";\r\nval e20 = Variable \"n12\";\r\n\r\n\r\nval sameAsConst = [(\"n1\",~1), (\"n2\",0), (\"n3\",1), (\"n4\",~2), (\"n5\",~3), \r\n                  (\"n6\",2), (\"n7\",3), (\"n8\",10), \r\n                  (\"n9\",43), (\"n10\",~43), (\"n11\", 5), (\"n12\",~5)];\r\n\r\n(*  some expressions with constant leaves *)\r\nval e1 = Constant ~1;\r\nval e2 = Constant 0\r\nval e3 = Constant 1;\r\nval e4 = Constant ~2\r\nval e5 = Constant ~3\r\nval e6 = Constant 2\r\nval e7 = Constant 3\r\nval e8 = Constant 10;\r\n\r\nval e21 = BinaryExp (ADD,e1,e2);\r\nval e22 = BinaryExp (ADD,e1,e5);\r\nval e23 = BinaryExp (ADD,e1,e8);\r\nval e24 = BinaryExp (ADD,e1,e3);\r\nval e25 = BinaryExp (ADD,e8,e8);\r\nval e26 = BinaryExp (SUBTRACT,e1,e2);\r\nval e27 = BinaryExp (SUBTRACT,e2,e1);\r\nval e28 = BinaryExp (SUBTRACT,e8,e8);\r\nval e29 = BinaryExp (SUBTRACT,e8,e7);\r\nval e30 = BinaryExp (SUBTRACT,e7,e8);\r\nval e31 = BinaryExp (MULT,e1,e2);\r\nval e32 = BinaryExp (MULT,e2,e3);\r\nval e33 = BinaryExp (MULT,e1,e8);\r\nval e34 = BinaryExp (MULT,e8,e3);\r\nval e35 = BinaryExp (MULT,e8,e5);\r\nval e36 = BinaryExp (MULT,e5,e7);\r\nval e37 = BinaryExp (MULT,e4,e5);\r\n\r\nval e38 = BinaryExp (DIV,e1,e2);\r\nval e39 = BinaryExp (DIV,e2,e3);\r\nval e40 = BinaryExp (DIV,e1,e8);\r\nval e41 = BinaryExp (DIV,e8,e3);\r\nval e42 = BinaryExp (DIV,e8,e5);\r\nval e43 = BinaryExp (DIV,e5,e7);\r\nval e44 = BinaryExp (DIV,e4,e5);\r\nval e45 = BinaryExp (DIV,e1,e2);\r\nval e46 = BinaryExp (DIV,(Constant 43),(Constant ~5));\r\nval e47 = BinaryExp (DIV,(Constant 43),(Constant 5));\r\nval e48 = BinaryExp (DIV,(Constant ~43),(Constant ~5));\r\nval e49 = BinaryExp (DIV,(Constant ~43),(Constant 5));\r\nval e50 = BinaryExp (MOD,e1,e2);\r\nval e51 = BinaryExp (MOD,e2,e3);\r\nval e52 = BinaryExp (MOD,e1,e8);\r\nval e53 = BinaryExp (MOD,e8,e3);\r\nval e54 = BinaryExp (MOD,e8,e5);\r\nval e55 = BinaryExp (MOD,e5,e7);\r\nval e56 = BinaryExp (MOD,e4,e5);\r\nval e57 = BinaryExp (MOD,e1,e2);\r\nval e58 = BinaryExp (MOD,(Constant 43),(Constant ~5));\r\nval e59 = BinaryExp (MOD,(Constant 43),(Constant 5));\r\nval e60 = BinaryExp (MOD,(Constant ~43),(Constant ~5));\r\nval e61 = BinaryExp (MOD,(Constant ~43),(Constant 5));\r\nval e62 = Negation (BinaryExp (ADD,e1,e2));\r\nval e63 = Negation (BinaryExp (ADD,e1,e5));\r\nval e64 = Negation (BinaryExp (ADD,e1,e8));\r\nval e65 = Negation (BinaryExp (ADD,e1,e3));\r\nval e66 = Negation (BinaryExp (ADD,e8,e8));\r\nval e67 = Negation (BinaryExp (SUBTRACT,e1,e2));\r\nval e68 = Negation (BinaryExp (SUBTRACT,e2,e1));\r\nval e69 = Negation (BinaryExp (SUBTRACT,e8,e8));\r\nval e70 = Negation (BinaryExp (SUBTRACT,e8,e7));\r\nval e71 = Negation (BinaryExp (SUBTRACT,e7,e8));\r\nval e72 = Negation (BinaryExp (MULT,e1,e2));\r\nval e73 = Negation (BinaryExp (MULT,e2,e3));\r\nval e74 = Negation (BinaryExp (MULT,e1,e8));\r\nval e75 = Negation (BinaryExp (MULT,e8,e3));\r\nval e76 = Negation (BinaryExp (MULT,e8,e5));\r\nval e77 = Negation (BinaryExp (MULT,e5,e7));\r\nval e78 = Negation (BinaryExp (MULT,e4,e5));\r\nval e79 = Negation (BinaryExp (DIV,e1,e2));\r\nval e80 = Negation (BinaryExp (DIV,e2,e3));\r\nval e81 = Negation (BinaryExp (DIV,e1,e8));\r\nval e82 = Negation (BinaryExp (DIV,e8,e3));\r\nval e83 = Negation (BinaryExp (DIV,e8,e5));\r\nval e84 = Negation (BinaryExp (DIV,e5,e7));\r\nval e85 = Negation (BinaryExp (DIV,e4,e5));\r\nval e86 = Negation (BinaryExp (DIV,e1,e2));\r\nval e87 = Negation (BinaryExp (DIV,(Constant 43),(Constant ~5)));\r\nval e88 = Negation (BinaryExp (DIV,(Constant 43),(Constant 5)));\r\nval e89 = Negation (BinaryExp (DIV,(Constant ~43),(Constant ~5)));\r\nval e90 = Negation (BinaryExp (DIV,(Constant ~43),(Constant 5)));\r\nval e91 = Negation (BinaryExp (MOD,e1,e2));\r\nval e92 = Negation (BinaryExp (MOD,e2,e3));\r\nval e93 = Negation (BinaryExp (MOD,e1,e8));\r\nval e94 = Negation (BinaryExp (MOD,e8,e3));\r\nval e95 = Negation (BinaryExp (MOD,e8,e5));\r\nval e96 = Negation (BinaryExp (MOD,e5,e7));\r\nval e97 = Negation (BinaryExp (MOD,e4,e5));\r\nval e98 = Negation (BinaryExp (MOD,e1,e2));\r\nval e99 = Negation (BinaryExp (MOD,(Constant 43),(Constant ~5)));\r\nval e100 = Negation (BinaryExp (MOD,(Constant 43),(Constant 5)));\r\nval e101 = Negation (BinaryExp (MOD,(Constant ~43),(Constant ~5)));\r\nval e102 = Negation (BinaryExp (MOD,(Constant ~43),(Constant 5)));\r\n\r\n(*  use the variables *)\r\n\r\nval e103 = BinaryExp (ADD,e1,e2);\r\nval e104 = BinaryExp (ADD,e1,e5);\r\nval e105 = BinaryExp (ADD,e1,e8);\r\nval e106 = BinaryExp (ADD,e1,e3);\r\nval e107 = BinaryExp (ADD,e8,e8);\r\nval e108 = BinaryExp (SUBTRACT,e1,e2);\r\nval e109 = BinaryExp (SUBTRACT,e2,e1);\r\nval e110 = BinaryExp (SUBTRACT,e8,e8);\r\nval e111 = BinaryExp (SUBTRACT,e8,e7);\r\nval e112 = BinaryExp (SUBTRACT,e7,e8);\r\nval e113 = BinaryExp (MULT,e1,e2);\r\nval e114 = BinaryExp (MULT,e2,e3);\r\nval e115 = BinaryExp (MULT,e1,e8);\r\nval e116 = BinaryExp (MULT,e8,e3);\r\nval e117 = BinaryExp (MULT,e8,e5);\r\nval e118 = BinaryExp (MULT,e5,e7);\r\nval e119 = BinaryExp (MULT,e4,e5);\r\n\r\nval e120 = BinaryExp (DIV,e1,e2);\r\nval e121 = BinaryExp (DIV,e2,e3);\r\nval e122 = BinaryExp (DIV,e1,e8);\r\nval e123 = BinaryExp (DIV,e8,e3);\r\nval e124 = BinaryExp (DIV,e8,e5);\r\nval e125 = BinaryExp (DIV,e5,e7);\r\nval e126 = BinaryExp (DIV,e4,e5);\r\nval e127 = BinaryExp (DIV,e1,e2);\r\nval e128 = BinaryExp (DIV,(e17),(e20));\r\nval e129 = BinaryExp (DIV,(e17),(e19));\r\nval e130 = BinaryExp (DIV,(e18),(e20));\r\nval e131 = BinaryExp (DIV,(e18),(e19));\r\n\r\nval e132 = BinaryExp (MOD,e1,e2);\r\nval e133 = BinaryExp (MOD,e2,e3);\r\nval e134 = BinaryExp (MOD,e1,e8);\r\nval e135 = BinaryExp (MOD,e8,e3);\r\nval e136 = BinaryExp (MOD,e8,e5);\r\nval e137 = BinaryExp (MOD,e5,e7);\r\nval e138 = BinaryExp (MOD,e4,e5);\r\nval e139 = BinaryExp (MOD,e1,e2);\r\nval e140 = BinaryExp (MOD,(e17),(e20));\r\nval e141 = BinaryExp (MOD,(e17),(e19));\r\nval e142 = BinaryExp (MOD,(e18),(e20));\r\nval e143 = BinaryExp (MOD,(e18),(e19));\r\n\r\nval e144 = Negation (BinaryExp (ADD,e1,e2));\r\nval e145 = Negation (BinaryExp (ADD,e1,e5));\r\nval e146 = Negation (BinaryExp (ADD,e1,e8));\r\nval e147 = Negation (BinaryExp (ADD,e1,e3));\r\nval e148 = Negation (BinaryExp (ADD,e8,e8));\r\nval e149 = Negation (BinaryExp (SUBTRACT,e1,e2));\r\nval e150 = Negation (BinaryExp (SUBTRACT,e2,e1));\r\nval e151 = Negation (BinaryExp (SUBTRACT,e8,e8));\r\nval e152 = Negation (BinaryExp (SUBTRACT,e8,e7));\r\nval e153 = Negation (BinaryExp (SUBTRACT,e7,e8));\r\nval e154 = Negation (BinaryExp (MULT,e1,e2));\r\nval e155 = Negation (BinaryExp (MULT,e2,e3));\r\nval e156 = Negation (BinaryExp (MULT,e1,e8));\r\nval e157 = Negation (BinaryExp (MULT,e8,e3));\r\nval e158 = Negation (BinaryExp (MULT,e8,e5));\r\nval e159 = Negation (BinaryExp (MULT,e5,e7));\r\nval e160 = Negation (BinaryExp (MULT,e4,e5));\r\n\r\nval e161 = Negation (BinaryExp (DIV,e1,e2));\r\nval e162 = Negation (BinaryExp (DIV,e2,e3));\r\nval e163 = Negation (BinaryExp (DIV,e1,e8));\r\nval e164 = Negation (BinaryExp (DIV,e8,e3));\r\nval e165 = Negation (BinaryExp (DIV,e8,e5));\r\nval e166 = Negation (BinaryExp (DIV,e5,e7));\r\nval e167 = Negation (BinaryExp (DIV,e4,e5));\r\nval e168 = Negation (BinaryExp (DIV,e1,e2));\r\nval e169 = Negation (BinaryExp (DIV,(e17),(e20)));\r\nval e170 = Negation (BinaryExp (DIV,(e17),(e19)));\r\nval e171 = Negation (BinaryExp (DIV,(e18),(e20)));\r\nval e172 = Negation (BinaryExp (DIV,(e18),(e19)));\r\n\r\nval e173 = Negation (BinaryExp (MOD,e1,e2));\r\nval e174 = Negation (BinaryExp (MOD,e2,e3));\r\nval e175 = Negation (BinaryExp (MOD,e1,e8));\r\nval e176 = Negation (BinaryExp (MOD,e8,e3));\r\nval e177 = Negation (BinaryExp (MOD,e8,e5));\r\nval e178 = Negation (BinaryExp (MOD,e5,e7));\r\nval e179 = Negation (BinaryExp (MOD,e4,e5));\r\nval e180 = Negation (BinaryExp (MOD,e1,e2));\r\nval e181 = Negation (BinaryExp (MOD,(e17),(e20)));\r\nval e182 = Negation (BinaryExp (MOD,(e17),(e19)));\r\nval e183 = Negation (BinaryExp (MOD,(e18),(e20)));\r\nval e183 = Negation (BinaryExp (MOD,(e18),(e19)));\r\n\r\n\r\nrunEvaluateExpression [] e1;\r\nrunEvaluateExpression [] e2;\r\nrunEvaluateExpression [] e3;\r\nrunEvaluateExpression [] e4;\r\nrunEvaluateExpression [] e5;\r\nrunEvaluateExpression [] e6;\r\nrunEvaluateExpression [] e7;\r\nrunEvaluateExpression [] e8;\r\nrunEvaluateExpression [] e9;\r\nrunEvaluateExpression [] e10;\r\nrunEvaluateExpression [] e11;\r\nrunEvaluateExpression [] e12;\r\nrunEvaluateExpression [] e13;\r\nrunEvaluateExpression [] e14;\r\nrunEvaluateExpression [] e15;\r\nrunEvaluateExpression [] e16;\r\nrunEvaluateExpression [] e17;\r\nrunEvaluateExpression [] e18;\r\nrunEvaluateExpression [] e19;\r\nrunEvaluateExpression [] e20;\r\nrunEvaluateExpression [] e21;\r\nrunEvaluateExpression [] e22;\r\nrunEvaluateExpression [] e23;\r\nrunEvaluateExpression [] e24;\r\nrunEvaluateExpression [] e25;\r\nrunEvaluateExpression [] e26;\r\nrunEvaluateExpression [] e27;\r\nrunEvaluateExpression [] e28;\r\nrunEvaluateExpression [] e29;\r\nrunEvaluateExpression [] e30;\r\nrunEvaluateExpression [] e31;\r\nrunEvaluateExpression [] e32;\r\nrunEvaluateExpression [] e33;\r\nrunEvaluateExpression [] e34;\r\nrunEvaluateExpression [] e35;\r\nrunEvaluateExpression [] e36;\r\nrunEvaluateExpression [] e37;\r\nrunEvaluateExpression [] e38;\r\nrunEvaluateExpression [] e39;\r\nrunEvaluateExpression [] e40;\r\nrunEvaluateExpression [] e41;\r\nrunEvaluateExpression [] e42;\r\nrunEvaluateExpression [] e43;\r\nrunEvaluateExpression [] e44;\r\nrunEvaluateExpression [] e45;\r\nrunEvaluateExpression [] e46;\r\nrunEvaluateExpression [] e47;\r\nrunEvaluateExpression [] e48;\r\nrunEvaluateExpression [] e49;\r\nrunEvaluateExpression [] e50;\r\nrunEvaluateExpression [] e51;\r\nrunEvaluateExpression [] e52;\r\nrunEvaluateExpression [] e53;\r\nrunEvaluateExpression [] e54;\r\nrunEvaluateExpression [] e55;\r\nrunEvaluateExpression [] e56;\r\nrunEvaluateExpression [] e57;\r\nrunEvaluateExpression [] e58;\r\nrunEvaluateExpression [] e59;\r\nrunEvaluateExpression [] e60;\r\nrunEvaluateExpression [] e61;\r\nrunEvaluateExpression [] e62;\r\nrunEvaluateExpression [] e63;\r\nrunEvaluateExpression [] e64;\r\nrunEvaluateExpression [] e65;\r\nrunEvaluateExpression [] e66;\r\nrunEvaluateExpression [] e67;\r\nrunEvaluateExpression [] e68;\r\nrunEvaluateExpression [] e69;\r\nrunEvaluateExpression [] e70;\r\nrunEvaluateExpression [] e71;\r\nrunEvaluateExpression [] e72;\r\nrunEvaluateExpression [] e73;\r\nrunEvaluateExpression [] e74;\r\nrunEvaluateExpression [] e75;\r\nrunEvaluateExpression [] e76;\r\nrunEvaluateExpression [] e77;\r\nrunEvaluateExpression [] e78;\r\nrunEvaluateExpression [] e79;\r\nrunEvaluateExpression [] e80;\r\nrunEvaluateExpression [] e81;\r\nrunEvaluateExpression [] e82;\r\nrunEvaluateExpression [] e83;\r\nrunEvaluateExpression [] e84;\r\nrunEvaluateExpression [] e85;\r\nrunEvaluateExpression [] e86;\r\nrunEvaluateExpression [] e87;\r\nrunEvaluateExpression [] e88;\r\nrunEvaluateExpression [] e89;\r\nrunEvaluateExpression [] e90;\r\nrunEvaluateExpression [] e91;\r\nrunEvaluateExpression [] e92;\r\nrunEvaluateExpression [] e93;\r\nrunEvaluateExpression [] e94;\r\nrunEvaluateExpression [] e95;\r\nrunEvaluateExpression [] e96;\r\nrunEvaluateExpression [] e97;\r\nrunEvaluateExpression [] e98;\r\nrunEvaluateExpression [] e99;\r\nrunEvaluateExpression [] e100;\r\nrunEvaluateExpression [] e101;\r\nrunEvaluateExpression [] e102;\r\nrunEvaluateExpression [] e103;\r\nrunEvaluateExpression [] e104;\r\nrunEvaluateExpression [] e105;\r\nrunEvaluateExpression [] e106;\r\nrunEvaluateExpression [] e107;\r\nrunEvaluateExpression [] e108;\r\nrunEvaluateExpression [] e109;\r\nrunEvaluateExpression [] e110;\r\nrunEvaluateExpression [] e111;\r\nrunEvaluateExpression [] e112;\r\nrunEvaluateExpression [] e113;\r\nrunEvaluateExpression [] e114;\r\nrunEvaluateExpression [] e115;\r\nrunEvaluateExpression [] e116;\r\nrunEvaluateExpression [] e117;\r\nrunEvaluateExpression [] e118;\r\nrunEvaluateExpression [] e119;\r\nrunEvaluateExpression [] e120;\r\nrunEvaluateExpression [] e121;\r\nrunEvaluateExpression [] e122;\r\nrunEvaluateExpression [] e123;\r\nrunEvaluateExpression [] e124;\r\nrunEvaluateExpression [] e125;\r\nrunEvaluateExpression [] e126;\r\nrunEvaluateExpression [] e127;\r\nrunEvaluateExpression [] e128;\r\nrunEvaluateExpression [] e129;\r\nrunEvaluateExpression [] e130;\r\nrunEvaluateExpression [] e131;\r\nrunEvaluateExpression [] e132;\r\nrunEvaluateExpression [] e133;\r\nrunEvaluateExpression [] e134;\r\nrunEvaluateExpression [] e135;\r\nrunEvaluateExpression [] e136;\r\nrunEvaluateExpression [] e137;\r\nrunEvaluateExpression [] e138;\r\nrunEvaluateExpression [] e139;\r\nrunEvaluateExpression [] e140;\r\nrunEvaluateExpression [] e141;\r\nrunEvaluateExpression [] e142;\r\nrunEvaluateExpression [] e143;\r\nrunEvaluateExpression [] e144;\r\nrunEvaluateExpression [] e145;\r\nrunEvaluateExpression [] e146;\r\nrunEvaluateExpression [] e147;\r\nrunEvaluateExpression [] e148;\r\nrunEvaluateExpression [] e149;\r\nrunEvaluateExpression [] e150;\r\nrunEvaluateExpression [] e151;\r\nrunEvaluateExpression [] e152;\r\nrunEvaluateExpression [] e153;\r\nrunEvaluateExpression [] e154;\r\nrunEvaluateExpression [] e155;\r\nrunEvaluateExpression [] e156;\r\nrunEvaluateExpression [] e157;\r\nrunEvaluateExpression [] e158;\r\nrunEvaluateExpression [] e159;\r\nrunEvaluateExpression [] e160;\r\nrunEvaluateExpression [] e161;\r\nrunEvaluateExpression [] e162;\r\nrunEvaluateExpression [] e163;\r\nrunEvaluateExpression [] e164;\r\nrunEvaluateExpression [] e165;\r\nrunEvaluateExpression [] e166;\r\nrunEvaluateExpression [] e167;\r\nrunEvaluateExpression [] e168;\r\nrunEvaluateExpression [] e169;\r\nrunEvaluateExpression [] e170;\r\nrunEvaluateExpression [] e171;\r\nrunEvaluateExpression [] e172;\r\nrunEvaluateExpression [] e173;\r\nrunEvaluateExpression [] e174;\r\nrunEvaluateExpression [] e175;\r\nrunEvaluateExpression [] e176;\r\nrunEvaluateExpression [] e177;\r\nrunEvaluateExpression [] e178;\r\nrunEvaluateExpression [] e179;\r\nrunEvaluateExpression [] e180;\r\nrunEvaluateExpression [] e181;\r\nrunEvaluateExpression [] e182;\r\nrunEvaluateExpression [] e183;\r\n\r\n\r\nrunEvaluateExpression sameAsConst e9;\r\nrunEvaluateExpression sameAsConst e10;\r\nrunEvaluateExpression sameAsConst e11;\r\nrunEvaluateExpression sameAsConst e12;\r\nrunEvaluateExpression sameAsConst e13;\r\nrunEvaluateExpression sameAsConst e14;\r\nrunEvaluateExpression sameAsConst e15;\r\nrunEvaluateExpression sameAsConst e16;\r\nrunEvaluateExpression sameAsConst e17;\r\nrunEvaluateExpression sameAsConst e18;\r\nrunEvaluateExpression sameAsConst e19;\r\nrunEvaluateExpression sameAsConst e20;\r\nrunEvaluateExpression sameAsConst e103;\r\nrunEvaluateExpression sameAsConst e104;\r\nrunEvaluateExpression sameAsConst e105;\r\nrunEvaluateExpression sameAsConst e106;\r\nrunEvaluateExpression sameAsConst e107;\r\nrunEvaluateExpression sameAsConst e108;\r\nrunEvaluateExpression sameAsConst e109;\r\nrunEvaluateExpression sameAsConst e110;\r\nrunEvaluateExpression sameAsConst e111;\r\nrunEvaluateExpression sameAsConst e112;\r\nrunEvaluateExpression sameAsConst e113;\r\nrunEvaluateExpression sameAsConst e114;\r\nrunEvaluateExpression sameAsConst e115;\r\nrunEvaluateExpression sameAsConst e116;\r\nrunEvaluateExpression sameAsConst e117;\r\nrunEvaluateExpression sameAsConst e118;\r\nrunEvaluateExpression sameAsConst e119;\r\nrunEvaluateExpression sameAsConst e120;\r\nrunEvaluateExpression sameAsConst e121;\r\nrunEvaluateExpression sameAsConst e122;\r\nrunEvaluateExpression sameAsConst e123;\r\nrunEvaluateExpression sameAsConst e124;\r\nrunEvaluateExpression sameAsConst e125;\r\nrunEvaluateExpression sameAsConst e126;\r\nrunEvaluateExpression sameAsConst e127;\r\nrunEvaluateExpression sameAsConst e128;\r\nrunEvaluateExpression sameAsConst e129;\r\nrunEvaluateExpression sameAsConst e130;\r\nrunEvaluateExpression sameAsConst e131;\r\nrunEvaluateExpression sameAsConst e132;\r\nrunEvaluateExpression sameAsConst e133;\r\nrunEvaluateExpression sameAsConst e134;\r\nrunEvaluateExpression sameAsConst e135;\r\nrunEvaluateExpression sameAsConst e136;\r\nrunEvaluateExpression sameAsConst e137;\r\nrunEvaluateExpression sameAsConst e138;\r\nrunEvaluateExpression sameAsConst e139;\r\nrunEvaluateExpression sameAsConst e140;\r\nrunEvaluateExpression sameAsConst e141;\r\nrunEvaluateExpression sameAsConst e142;\r\nrunEvaluateExpression sameAsConst e143;\r\nrunEvaluateExpression sameAsConst e144;\r\nrunEvaluateExpression sameAsConst e145;\r\nrunEvaluateExpression sameAsConst e146;\r\nrunEvaluateExpression sameAsConst e147;\r\nrunEvaluateExpression sameAsConst e148;\r\nrunEvaluateExpression sameAsConst e149;\r\nrunEvaluateExpression sameAsConst e150;\r\nrunEvaluateExpression sameAsConst e151;\r\nrunEvaluateExpression sameAsConst e152;\r\nrunEvaluateExpression sameAsConst e153;\r\nrunEvaluateExpression sameAsConst e154;\r\nrunEvaluateExpression sameAsConst e155;\r\nrunEvaluateExpression sameAsConst e156;\r\nrunEvaluateExpression sameAsConst e157;\r\nrunEvaluateExpression sameAsConst e158;\r\nrunEvaluateExpression sameAsConst e159;\r\nrunEvaluateExpression sameAsConst e160;\r\nrunEvaluateExpression sameAsConst e161;\r\nrunEvaluateExpression sameAsConst e162;\r\nrunEvaluateExpression sameAsConst e163;\r\nrunEvaluateExpression sameAsConst e164;\r\nrunEvaluateExpression sameAsConst e165;\r\nrunEvaluateExpression sameAsConst e166;\r\nrunEvaluateExpression sameAsConst e167;\r\nrunEvaluateExpression sameAsConst e168;\r\nrunEvaluateExpression sameAsConst e169;\r\nrunEvaluateExpression sameAsConst e170;\r\nrunEvaluateExpression sameAsConst e171;\r\nrunEvaluateExpression sameAsConst e172;\r\nrunEvaluateExpression sameAsConst e173;\r\nrunEvaluateExpression sameAsConst e174;\r\nrunEvaluateExpression sameAsConst e175;\r\nrunEvaluateExpression sameAsConst e176;\r\nrunEvaluateExpression sameAsConst e177;\r\nrunEvaluateExpression sameAsConst e178;\r\nrunEvaluateExpression sameAsConst e179;\r\nrunEvaluateExpression sameAsConst e180;\r\nrunEvaluateExpression sameAsConst e181;\r\nrunEvaluateExpression sameAsConst e182;\r\nrunEvaluateExpression sameAsConst e183;\r\n\r\n(*\r\n\r\n10.\r\n\r\nThe following is a Java code fragment that calculates the\r\ninteger quotient and integer remainder of n divided d, for \r\nintegers n and d, which are assumed already given as input.\r\nThe variable q holds the quotient, and the variable r holds the remainder.\r\n\r\n{\r\n\r\nint q, r;\r\nboolean nNeg, dNeg;\r\n\r\n\r\nif (n < 0){\r\n   n = -n;\r\n   nNeg = true;\r\n}\r\nelse\r\n   nNeg = false;\r\n\r\nif (d < 0){\r\n   dNeg = true;\r\n   d = -d;\r\n}\r\nelse\r\n   dNeg = false;\r\n\r\nq = 0;\r\n\r\nwhile (n >= d){\r\n   n = n - d;\r\n   q = q + 1;\r\n}\r\n\r\nr = n;\r\n\r\nif (nNeg)\r\n   r = -r;\r\n\r\nif (nNeg != rNeg)\r\n   q = -q;   \r\n\r\n}\r\n\r\nThe state for this imperative fragment is the tuple of values for \r\n\r\n(n, d, q, r, nNeg, dNeg)\r\n\r\nwhich is in\r\n\r\nint * int * int * int * bool * bool\r\n\r\ncode the following four functions\r\n\r\n1. preLoop : int * int -> int * int * int * int * bool * bool\r\n\r\n   so that preLoop (n, d) = the state vector that would hold  if the\r\n   initial code above the loop\r\n\r\n\r\n   if (n < 0){\r\n      n = -n;\r\n      nNeg = true;\r\n   }\r\n   else\r\n      nNeg = false;\r\n\r\n   if (d < 0){\r\n      dNeg = true;\r\n      d = -d;\r\n   }\r\n   else\r\n      dNeg = false;\r\n\r\n   q = 0;\r\n\r\n\r\n\r\n  were executed for this particular n and d.  Note, r is not assigned\r\n  to, so you can just use 0 for  r's value.  The list should be\r\n\r\n  (n's value after the initial piece, d's value after the initial piece,\r\n  q's value after the initial piece, 0, nNeg's value after the initial\r\n  piece, dNeg's value of the initial piece)\r\n\r\n2. loopBody : int * int * int * int * bool * bool -> int * int * int * int * bool * bool\r\n\r\n   to effect the state change on (n, d, q, r, nNeg, dNeg) that is wrought by the two\r\n   statements of the loop body\r\n\r\n   n = n - d;\r\n   q = q + 1;\r\n\r\n3. loop : int * int * int * int * bool * bool -> int * int * int * int * bool * bool\r\n\r\n   a recursive function to bring about the effect on a state of executing the loop to\r\n   completion, using your loopBody function.\r\n\r\n4. postLoop : int * int * int * int * bool * bool -> int * int * int * int * bool * bool\r\n\r\n   to modify the state as the statements after the loop,\r\n\r\n   r = n;\r\n\r\n   if (nNeg)\r\n      r = -r;\r\n\r\n   if (nNeg != rNeg)\r\n      q = -q;   \r\n\r\n\r\nRemember, unary minus/negation in ML is ~, the tilde.\r\n\r\nThe code below uses these functions to perform the calculation of (n div d, n mod d)\r\n\r\nYOU MUST CODE preLoop, loop, loopBody, and postLoop.\r\n\r\n*)\r\n\r\nfun preLoop(n : int, d : int) =  (0, 0, 0, 0, true, false);\r\n\r\n\r\nfun loopBody (n : int, d :int, q : int, r : int, nN : bool, dN : bool) =\r\n   (0, 0, 0, 0, true, false);\r\n\r\nfun loop(n : int, d :int, q : int, r : int, nN : bool, dN : bool) =\r\n   (0, 0, 0, 0, true, false);\r\n\r\nfun postLoop(n : int, d :int, q : int, r : int, nN : bool, dN : bool) =\r\n   (0, 0, 0, 0, true, false);\r\n\r\nfun calcQuoAndRem (n : int, d : int) =\r\n   (* to cover an invalid case *)\r\n   if d = 0 then\r\n      (0, 0)\r\n   else\r\n      let\r\n         val result = postLoop( loop ( preLoop (n, d)))\r\n      in\r\n         (#3 result, #4 result)\r\n      end;\r\n\r\n\r\ncalcQuoAndRem (37, 5);\r\ncalcQuoAndRem (37, ~5);\r\ncalcQuoAndRem (~37, 5);\r\ncalcQuoAndRem (~37, ~5);\r\ncalcQuoAndRem (60, 5);\r\ncalcQuoAndRem (60, ~5);\r\ncalcQuoAndRem (~60, 5);\r\ncalcQuoAndRem (~60, ~5);\r\ncalcQuoAndRem (60, 61);\r\ncalcQuoAndRem (60, ~61);\r\ncalcQuoAndRem (~60, 61);\r\ncalcQuoAndRem (~60, ~61);\r\ncalcQuoAndRem (~60, 0);\r\ncalcQuoAndRem (60, 0);\r\n\r\n\r\n(*\r\n\r\nIn Java, it should be that\r\n\r\nx - (x/y) * y = x % y\r\n\r\nfor all integers x and y with y not 0;\r\n\r\nnote, this is not what it would be in ML\r\n\r\nThe following function tests that equality.\r\n\r\n*)\r\n\r\nfun testQuoRem (n:int, d:int) =\r\n   let\r\n      val (quo, rem) = calcQuoAndRem(n, d)\r\n   in\r\n      n - quo * d = rem\r\n   end;\r\n\r\n(*\r\n\r\nall but the last two of these should be true; the last two\r\nfail because the divisor d is 0.\r\n\r\n*)\r\n\r\ntestQuoRem(37, 5);\r\ntestQuoRem(37, ~5);\r\ntestQuoRem(~37, 5);\r\ntestQuoRem(~37, ~5);\r\ntestQuoRem(60, 5);\r\ntestQuoRem(60, ~5);\r\ntestQuoRem(~60, 5);\r\ntestQuoRem(~60, ~5);\r\ntestQuoRem(60, 61);\r\ntestQuoRem(60, ~61);\r\ntestQuoRem(~60, 61);\r\ntestQuoRem(~60, ~61);\r\ntestQuoRem(~60, 0);\r\ntestQuoRem(60, 0);\r\n\r\n\r\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/ben/Downloads/MLTeamProbsF18.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/ben/Downloads/MLTeamProbsF18.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/ben/Downloads/MLTeamProbsF18.ml"},"position":{"line":9,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/ben/Downloads/MLTeamProbsF18.ml"}}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"shutdown","params":null}
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
